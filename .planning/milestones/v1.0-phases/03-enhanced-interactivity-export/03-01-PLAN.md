---
phase: 03-enhanced-interactivity-export
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/game-plan-graph.ts
  - src/components/game-plan/labeled-edge.tsx
  - src/components/game-plan/flowchart-view.tsx
autonomous: true

must_haves:
  truths:
    - "Hovering a technique node dims unconnected nodes/edges and highlights connected ones"
    - "Hovering an edge dims unconnected nodes/edges and highlights the hovered edge and its endpoints"
    - "Hovering a technique->position edge shows a tooltip with the technique name and type"
    - "Position->technique edges do not show a tooltip (no redundant information)"
    - "Mouse leave resets all nodes and edges to full opacity"
  artifacts:
    - path: "src/components/game-plan/labeled-edge.tsx"
      provides: "Custom edge component with EdgeLabelRenderer tooltip on hover"
    - path: "src/lib/game-plan-graph.ts"
      provides: "Edge data extended with techniqueName and techniqueType for technique->position edges"
    - path: "src/components/game-plan/flowchart-view.tsx"
      provides: "Hover handlers (onNodeMouseEnter/Leave, onEdgeMouseEnter/Leave) and edgeTypes registration"
  key_links:
    - from: "src/lib/game-plan-graph.ts"
      to: "src/components/game-plan/labeled-edge.tsx"
      via: "edge data.techniqueName and data.techniqueType populated in graph builder, consumed by LabeledEdge"
      pattern: "data:\\s*\\{\\s*techniqueName"
    - from: "src/components/game-plan/flowchart-view.tsx"
      to: "src/components/game-plan/labeled-edge.tsx"
      via: "edgeTypes record registers LabeledEdge as default edge type"
      pattern: "edgeTypes.*labeled"
---

<objective>
Add hover-based path highlighting and edge tooltips to the flowchart.

Purpose: Users can visually trace technique connections by hovering nodes or edges — dimming unrelated parts of the graph and surfacing technique name/type on edge hover. This makes the flowchart readable at scale.

Output: LabeledEdge component, extended edge data in graph builder, hover handlers in FlowchartView.
</objective>

<execution_context>
@C:/Users/cappi/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/cappi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-enhanced-interactivity-export/03-RESEARCH.md

@src/lib/game-plan-graph.ts
@src/components/game-plan/flowchart-view.tsx
@src/components/game-plan/technique-node.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend edge data in graph builder and create LabeledEdge component</name>
  <files>src/lib/game-plan-graph.ts, src/components/game-plan/labeled-edge.tsx</files>
  <action>
**game-plan-graph.ts changes:**
1. Update the edge array type from `Array<{ id: string; source: string; target: string }>` to include an optional `data` field: `Array<{ id: string; source: string; target: string; data?: { techniqueName?: string; techniqueType?: string } }>`.
2. For technique->position edges (the `e-tech-pos-{id}` edges created when `!isSubmission && technique.resultingPositionId`), add `data: { techniqueName: technique.name, techniqueType: technique.type }`.
3. Position->technique edges (`e-pos-tech-{id}`) should NOT have data populated — they connect a position to a technique; the technique name is already visible on the technique node.

**labeled-edge.tsx (new file):**
1. Create `src/components/game-plan/labeled-edge.tsx`.
2. Import `BaseEdge`, `EdgeLabelRenderer`, `getBezierPath`, and `type EdgeProps` from `@xyflow/react`. Import `useState` from React.
3. Export a `LabeledEdge` function component accepting `EdgeProps`.
4. Destructure: `id, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, data, markerEnd, style`.
5. Use `useState(false)` for `isHovered`.
6. Compute `[edgePath, labelX, labelY]` from `getBezierPath(...)`.
7. Render `<BaseEdge>` with `interactionWidth={20}` and `onMouseEnter`/`onMouseLeave` toggling `isHovered`.
8. Conditionally render (when `isHovered && data?.techniqueName`) an `<EdgeLabelRenderer>` child with a tooltip div:
   - Classes: `nodrag nopan absolute bg-card border border-border/70 rounded-md px-2 py-1 text-xs shadow-md`
   - Style: `{ transform: \`translate(-50%, -100%) translate(${labelX}px, ${labelY - 8}px)\`, pointerEvents: "none" }`
   - Content: technique name in `<span className="font-medium text-foreground">` and technique type (if present) in `<span className="ml-1.5 text-muted-foreground capitalize">`.
9. Use named export, no memo needed (edges are simple).
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors. Verify LabeledEdge file exists and exports the component. Verify game-plan-graph.ts edges include data for technique->position edges.</verify>
  <done>LabeledEdge component renders tooltip on hover for edges with techniqueName data. Graph builder populates data on technique->position edges only.</done>
</task>

<task type="auto">
  <name>Task 2: Wire hover highlighting and edge types into FlowchartView</name>
  <files>src/components/game-plan/flowchart-view.tsx</files>
  <action>
**FlowchartView changes:**

1. Add imports: `getIncomers`, `getOutgoers` from `@xyflow/react`. Import `{ LabeledEdge }` from `./labeled-edge`.

2. Define `edgeTypes` constant OUTSIDE the component (same pattern as `nodeTypes`):
   ```typescript
   const edgeTypes: Record<string, any> = { default: LabeledEdge };
   ```
   This makes LabeledEdge the default edge type for ALL edges. Edges without `data.techniqueName` simply won't show the tooltip (the conditional render handles this).

3. Add `setEdges` to the `useEdgesState` destructuring (currently the second element is unused: `const [edges, , onEdgesChange]` becomes `const [edges, setEdges, onEdgesChange]`).

4. Create `onNodeMouseEnter` callback (wrapped in `useCallback` with deps `[nodes, edges, setNodes, setEdges]`):
   - Compute `connected` Set: hovered node ID + IDs from `getIncomers(hoveredNode, nodes, edges)` + IDs from `getOutgoers(hoveredNode, nodes, edges)`.
   - Compute `connectedEdgeIds` Set: edges where `source === hoveredNode.id || target === hoveredNode.id`.
   - Call `setNodes` mapping each node to `{ ...n, style: { ...n.style, opacity: connected.has(n.id) ? 1 : 0.2 } }`.
   - Call `setEdges` mapping each edge to `{ ...e, style: { ...e.style, opacity: connectedEdgeIds.has(e.id) ? 1 : 0.15 }, animated: connectedEdgeIds.has(e.id) }`.

5. Create `onNodeMouseLeave` callback (wrapped in `useCallback` with deps `[setNodes, setEdges]`):
   - Reset: `setNodes(nds => nds.map(n => ({ ...n, style: { ...n.style, opacity: 1 } })))`.
   - Reset: `setEdges(eds => eds.map(e => ({ ...e, style: { ...e.style, opacity: 1 }, animated: false })))`.

6. Create `onEdgeMouseEnter` callback (wrapped in `useCallback` with deps `[setNodes, setEdges]`):
   - Compute `connectedNodeIds` Set: `[hoveredEdge.source, hoveredEdge.target]`.
   - Call `setNodes` dimming non-connected nodes to opacity 0.2.
   - Call `setEdges` dimming non-hovered edges to opacity 0.15.

7. Create `onEdgeMouseLeave` — reuse same logic as `onNodeMouseLeave` (or alias it).

8. Pass to `<ReactFlow>`: `edgeTypes={edgeTypes}`, `onNodeMouseEnter={onNodeMouseEnter}`, `onNodeMouseLeave={onNodeMouseLeave}`, `onEdgeMouseEnter={onEdgeMouseEnter}`, `onEdgeMouseLeave={onEdgeMouseLeave}`.

9. Update `initialEdges` memo: the input edges now have optional `data` field. Preserve it in the mapping: `...e` spread already carries `data` through. Verify the type signature allows `data`.

**Critical: All event handlers MUST be wrapped in useCallback to prevent render loops** (see research pitfall 4).
  </action>
  <verify>Run `npx tsc --noEmit` — no type errors. Run `npm run dev`, open game plan with techniques, hover a technique node — unconnected nodes/edges dim. Hover a technique->position edge — tooltip shows technique name and type. Mouse leave restores everything to full opacity.</verify>
  <done>Hovering any node or edge highlights connected paths and dims unconnected ones. Technique->position edges show tooltip on hover. All hover state is local to FlowchartView (not in Zustand).</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. Hover a technique node: connected position nodes and edges stay bright, everything else dims to 0.2/0.15 opacity
3. Hover a technique->position edge: tooltip appears showing technique name and type at edge midpoint
4. Hover a position->technique edge: path highlighting works but NO tooltip appears (correct — no redundant info)
5. Mouse leave on any node/edge: full opacity restored, no stuck states
6. No render loops: browser CPU stays normal during hover interactions
</verification>

<success_criteria>
- LabeledEdge component renders tooltip conditionally based on edge data
- Graph builder populates techniqueName/techniqueType on technique->position edges only
- All hover handlers wrapped in useCallback, no render loops
- Opacity transitions are smooth and reversible
- INTX-06 (path highlighting) and INTX-07 (edge tooltip) requirements met
</success_criteria>

<output>
After completion, create `.planning/phases/03-enhanced-interactivity-export/03-01-SUMMARY.md`
</output>
